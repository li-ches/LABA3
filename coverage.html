
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>ds: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">datastructures/ds/arr.go (87.9%)</option>
				
				<option value="file1">datastructures/ds/cbt.go (92.1%)</option>
				
				<option value="file2">datastructures/ds/dlist.go (86.8%)</option>
				
				<option value="file3">datastructures/ds/hash.go (89.7%)</option>
				
				<option value="file4">datastructures/ds/list.go (90.2%)</option>
				
				<option value="file5">datastructures/ds/queue.go (88.5%)</option>
				
				<option value="file6">datastructures/ds/serialize.go (95.0%)</option>
				
				<option value="file7">datastructures/ds/stack.go (89.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package ds

import (
        "encoding/binary"
        "fmt"
        "os"
)

// MyArr - динамический массив строк
type MyArr struct {
        data []string
}

// NewMyArr создает новый массив
func NewMyArr() *MyArr <span class="cov8" title="1">{
        return &amp;MyArr{
                data: make([]string, 0),
        }
}</span>

// AddEnd добавляет элемент в конец
func (a *MyArr) AddEnd(val string) <span class="cov8" title="1">{
        a.data = append(a.data, val)
}</span>

// AddHead добавляет элемент в начало
func (a *MyArr) AddHead(val string) <span class="cov8" title="1">{
        a.data = append([]string{val}, a.data...)
}</span>

// AddAt добавляет элемент по индексу
func (a *MyArr) AddAt(idx int, val string) <span class="cov8" title="1">{
        if idx &lt; 0 || idx &gt; len(a.data) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if idx == len(a.data) </span><span class="cov8" title="1">{
                a.AddEnd(val)
                return
        }</span>
        <span class="cov8" title="1">a.data = append(a.data[:idx+1], a.data[idx:]...)
        a.data[idx] = val</span>
}

// DelHead удаляет элемент из начала
func (a *MyArr) DelHead() <span class="cov8" title="1">{
        if len(a.data) == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">a.data = a.data[1:]</span>
}

// DelEnd удаляет элемент из конца
func (a *MyArr) DelEnd() <span class="cov8" title="1">{
        if len(a.data) == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">a.data = a.data[:len(a.data)-1]</span>
}

// DelAt удаляет элемент по индексу
func (a *MyArr) DelAt(idx int) <span class="cov8" title="1">{
        if idx &lt; 0 || idx &gt;= len(a.data) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">a.data = append(a.data[:idx], a.data[idx+1:]...)</span>
}

// RepArr заменяет элемент по индексу
func (a *MyArr) RepArr(idx int, val string) <span class="cov8" title="1">{
        if idx &lt; 0 || idx &gt;= len(a.data) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov0" title="0">a.data[idx] = val</span>
}

// GetAt возвращает элемент по индексу
func (a *MyArr) GetAt(idx int) string <span class="cov8" title="1">{
        if idx &gt;= 0 &amp;&amp; idx &lt; len(a.data) </span><span class="cov8" title="1">{
                return a.data[idx]
        }</span>
        <span class="cov8" title="1">return "[INVALID_INDEX]"</span>
}

// LenArr возвращает длину массива
func (a *MyArr) LenArr() int <span class="cov8" title="1">{
        return len(a.data)
}</span>

// ReadArray выводит содержимое массива
func (a *MyArr) ReadArray() <span class="cov8" title="1">{
        if len(a.data) == 0 </span><span class="cov8" title="1">{
                fmt.Println("Массив пуст.")
                return
        }</span>
        <span class="cov0" title="0">fmt.Printf("Содержимое массива (%d/%d): ", len(a.data), cap(a.data))
        for _, val := range a.data </span><span class="cov0" title="0">{
                fmt.Printf("\"%s\" ", val)
        }</span>
        <span class="cov0" title="0">fmt.Println()</span>
}

// SaveToFile сохраняет массив в файл
func (a *MyArr) SaveToFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        size := int32(len(a.data))
        if err := binary.Write(file, binary.LittleEndian, size); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, val := range a.data </span><span class="cov8" title="1">{
                if err := WriteString(file, val); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// LoadFromFile загружает массив из файла
func (a *MyArr) LoadFromFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        a.data = make([]string, 0)
        var size int32
        if err := binary.Read(file, binary.LittleEndian, &amp;size); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">for i := int32(0); i &lt; size; i++ </span><span class="cov8" title="1">{
                val, err := ReadString(file)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">a.AddEnd(val)</span>
        }
        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package ds

import (
        "fmt"
        "os"
)

// CBTNode - узел дерева
type CBTNode struct {
        Data  int32 // C++ int обычно 32-битный
        Left  *CBTNode
        Right *CBTNode
}

// CompleteBinaryTree - аналог класса из compl.h
type CompleteBinaryTree struct {
        Root *CBTNode
        Size int
}

// NewCBT - конструктор
func NewCBT() *CompleteBinaryTree <span class="cov8" title="1">{
        return &amp;CompleteBinaryTree{
                Root: nil,
                Size: 0,
        }
}</span>

// insertRec - рекурсивная вставка (как в compl.cpp)
func (t *CompleteBinaryTree) insertRec(node *CBTNode, value int32) *CBTNode <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                t.Size++
                fmt.Printf("Элемент %d добавлен\n", value)
                return &amp;CBTNode{Data: value}
        }</span>

        <span class="cov8" title="1">if value &lt; node.Data </span><span class="cov8" title="1">{
                node.Left = t.insertRec(node.Left, value)
        }</span> else<span class="cov8" title="1"> if value &gt; node.Data </span><span class="cov8" title="1">{
                node.Right = t.insertRec(node.Right, value)
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("Элемент %d уже существует.\n", value)
        }</span>
        <span class="cov8" title="1">return node</span>
}

// Insert - публичный метод вставки
func (t *CompleteBinaryTree) Insert(value int) <span class="cov8" title="1">{
        t.Root = t.insertRec(t.Root, int32(value))
}</span>

// findMin - поиск минимума
func (t *CompleteBinaryTree) findMin(node *CBTNode) *CBTNode <span class="cov8" title="1">{
        for node != nil &amp;&amp; node.Left != nil </span><span class="cov8" title="1">{
                node = node.Left
        }</span>
        <span class="cov8" title="1">return node</span>
}

// deleteNodeRec - рекурсивное удаление
func (t *CompleteBinaryTree) deleteNodeRec(node *CBTNode, value int32) *CBTNode <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if value &lt; node.Data </span><span class="cov8" title="1">{
                node.Left = t.deleteNodeRec(node.Left, value)
        }</span> else<span class="cov8" title="1"> if value &gt; node.Data </span><span class="cov8" title="1">{
                node.Right = t.deleteNodeRec(node.Right, value)
        }</span> else<span class="cov8" title="1"> {
                // Узел найден

                // Случай 1: Нет левого потомка
                if node.Left == nil </span><span class="cov8" title="1">{
                        temp := node.Right
                        t.Size--
                        return temp
                }</span>
                // Случай 2: Нет правого потомка
                <span class="cov8" title="1">if node.Right == nil </span><span class="cov8" title="1">{
                        temp := node.Left
                        t.Size--
                        return temp
                }</span>

                // Случай 3: Есть оба потомка
                <span class="cov8" title="1">successor := t.findMin(node.Right)
                node.Data = successor.Data
                node.Right = t.deleteNodeRec(node.Right, successor.Data)</span>
        }
        <span class="cov8" title="1">return node</span>
}

// Remove - удаление элемента
func (t *CompleteBinaryTree) Remove(value int) <span class="cov8" title="1">{
        if t.Root == nil </span><span class="cov8" title="1">{
                fmt.Println("Нельзя удалить из пустого дерева.")
                return
        }</span>
        <span class="cov8" title="1">initialSize := t.Size
        t.Root = t.deleteNodeRec(t.Root, int32(value))

        if t.Size &lt; initialSize </span><span class="cov8" title="1">{
                fmt.Printf("Элемент %d удален.\n", value)
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("Элемент %d не найден.\n", value)
        }</span>
}

// Search - поиск элемента
func (t *CompleteBinaryTree) Search(value int) bool <span class="cov8" title="1">{
        if t.Root == nil </span><span class="cov8" title="1">{
                fmt.Println("Поиск в пустом дереве.")
                return false
        }</span>
        <span class="cov8" title="1">cur := t.Root
        val := int32(value)
        for cur != nil </span><span class="cov8" title="1">{
                if cur.Data == val </span><span class="cov8" title="1">{
                        fmt.Printf("Элемент %d найден.\n", value)
                        return true
                }</span>
                <span class="cov8" title="1">if val &lt; cur.Data </span><span class="cov8" title="1">{
                        cur = cur.Left
                }</span> else<span class="cov8" title="1"> {
                        cur = cur.Right
                }</span>
        }
        <span class="cov8" title="1">fmt.Printf("Элемент %d не найден.\n", value)
        return false</span>
}

// printTreeUtil - вспомогательная функция печати
func (t *CompleteBinaryTree) printTreeUtil(node *CBTNode, prefix string, isLast bool) <span class="cov8" title="1">{
        if node == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">fmt.Print(prefix)
        if isLast </span><span class="cov8" title="1">{
                fmt.Print("└──")
        }</span> else<span class="cov8" title="1"> {
                fmt.Print("├──")
        }</span>
        <span class="cov8" title="1">fmt.Println(node.Data)

        childPrefix := prefix
        if isLast </span><span class="cov8" title="1">{
                childPrefix += "    "
        }</span> else<span class="cov8" title="1"> {
                childPrefix += "│   "
        }</span>

        <span class="cov8" title="1">if node.Left != nil &amp;&amp; node.Right != nil </span><span class="cov0" title="0">{
                t.printTreeUtil(node.Left, childPrefix, false)
                t.printTreeUtil(node.Right, childPrefix, true)
        }</span> else<span class="cov8" title="1"> if node.Left != nil </span><span class="cov8" title="1">{
                t.printTreeUtil(node.Left, childPrefix, true)
        }</span> else<span class="cov8" title="1"> if node.Right != nil </span><span class="cov8" title="1">{
                t.printTreeUtil(node.Right, childPrefix, true)
        }</span>
}

// Print - печать дерева
func (t *CompleteBinaryTree) Print() <span class="cov8" title="1">{
        if t.Root == nil </span><span class="cov8" title="1">{
                fmt.Println("Дерево пустое.")
                return
        }</span>
        <span class="cov8" title="1">fmt.Println("------------------------------------------")
        fmt.Printf("Дерево (размер: %d):\n", t.Size)

        fmt.Println(t.Root.Data)
        if t.Root.Left != nil &amp;&amp; t.Root.Right != nil </span><span class="cov8" title="1">{
                t.printTreeUtil(t.Root.Left, "", false)
                t.printTreeUtil(t.Root.Right, "", true)
        }</span> else<span class="cov0" title="0"> if t.Root.Left != nil </span><span class="cov0" title="0">{
                t.printTreeUtil(t.Root.Left, "", true)
        }</span> else<span class="cov0" title="0"> if t.Root.Right != nil </span><span class="cov0" title="0">{
                t.printTreeUtil(t.Root.Right, "", true)
        }</span>
        <span class="cov8" title="1">fmt.Println("------------------------------------------")</span>
}

// Clear - очистка дерева
func (t *CompleteBinaryTree) Clear() <span class="cov8" title="1">{
        t.Root = nil
        t.Size = 0
        fmt.Println("Дерево очищено.")
}</span>

// Contains - метод для совместимости с интерфейсом тестов
func (t *CompleteBinaryTree) Contains(val int) bool <span class="cov8" title="1">{
        cur := t.Root
        v := int32(val)
        for cur != nil </span><span class="cov8" title="1">{
                if cur.Data == v </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">if v &lt; cur.Data </span><span class="cov8" title="1">{
                        cur = cur.Left
                }</span> else<span class="cov8" title="1"> {
                        cur = cur.Right
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// --- СЕРИАЛИЗАЦИЯ ---

func (t *CompleteBinaryTree) saveBinaryRec(node *CBTNode, file *os.File) error <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                // Маркер null-узла: -1
                return WriteInt32(file, -1)
        }</span>
        <span class="cov8" title="1">if err := WriteInt32(file, node.Data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := t.saveBinaryRec(node.Left, file); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := t.saveBinaryRec(node.Right, file); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (t *CompleteBinaryTree) SaveToFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        return t.saveBinaryRec(t.Root, file)</span>
}

func (t *CompleteBinaryTree) loadBinaryRec(file *os.File) (*CBTNode, error) <span class="cov8" title="1">{
        val, err := ReadInt32(file)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if val == -1 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">node := &amp;CBTNode{Data: val}
        t.Size++

        left, err := t.loadBinaryRec(file)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">node.Left = left

        right, err := t.loadBinaryRec(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">node.Right = right

        return node, nil</span>
}

func (t *CompleteBinaryTree) LoadFromFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        t.Clear() 
        t.Size = 0 

        root, err := t.loadBinaryRec(file)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">t.Root = root
        return nil</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package ds

import (
        "encoding/binary"
        "fmt"
        "os"
)

type DNode struct {
        Value string
        Next  *DNode
        Prev  *DNode
}

type DList struct {
        Head *DNode
        Tail *DNode
}

func NewDList() *DList <span class="cov8" title="1">{
        return &amp;DList{}
}</span>

func (d *DList) AddHead(val string) <span class="cov8" title="1">{
        node := &amp;DNode{Value: val, Next: d.Head, Prev: nil}
        if d.Head != nil </span><span class="cov8" title="1">{
                d.Head.Prev = node
        }</span> else<span class="cov8" title="1"> {
                d.Tail = node
        }</span>
        <span class="cov8" title="1">d.Head = node</span>
}

func (d *DList) AddTail(val string) <span class="cov8" title="1">{
        node := &amp;DNode{Value: val, Next: nil, Prev: d.Tail}
        if d.Tail != nil </span><span class="cov8" title="1">{
                d.Tail.Next = node
        }</span> else<span class="cov8" title="1"> {
                d.Head = node
        }</span>
        <span class="cov8" title="1">d.Tail = node</span>
}

func (d *DList) AddBefore(target, val string) <span class="cov8" title="1">{
        if d.Head == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">for cur := d.Head; cur != nil; cur = cur.Next </span><span class="cov8" title="1">{
                if cur.Value == target </span><span class="cov8" title="1">{
                        node := &amp;DNode{Value: val, Next: cur, Prev: cur.Prev}
                        if cur.Prev != nil </span><span class="cov8" title="1">{
                                cur.Prev.Next = node
                        }</span> else<span class="cov0" title="0"> {
                                d.Head = node
                        }</span>
                        <span class="cov8" title="1">cur.Prev = node
                        return</span>
                }
        }
}

func (d *DList) AddAfter(target, val string) <span class="cov8" title="1">{
        if d.Head == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">for cur := d.Head; cur != nil; cur = cur.Next </span><span class="cov8" title="1">{
                if cur.Value == target </span><span class="cov8" title="1">{
                        node := &amp;DNode{Value: val, Next: cur.Next, Prev: cur}
                        if cur.Next != nil </span><span class="cov8" title="1">{
                                cur.Next.Prev = node
                        }</span> else<span class="cov0" title="0"> {
                                d.Tail = node
                        }</span>
                        <span class="cov8" title="1">cur.Next = node
                        return</span>
                }
        }
}

func (d *DList) DelHead() <span class="cov8" title="1">{
        if d.Head == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">d.Head = d.Head.Next
        if d.Head != nil </span><span class="cov0" title="0">{
                d.Head.Prev = nil
        }</span> else<span class="cov8" title="1"> {
                d.Tail = nil
        }</span>
}

func (d *DList) DelTail() <span class="cov8" title="1">{
        if d.Tail == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">d.Tail = d.Tail.Prev
        if d.Tail != nil </span><span class="cov0" title="0">{
                d.Tail.Next = nil
        }</span> else<span class="cov8" title="1"> {
                d.Head = nil
        }</span>
}

func (d *DList) findNode(val string) *DNode <span class="cov8" title="1">{
        for cur := d.Head; cur != nil; cur = cur.Next </span><span class="cov8" title="1">{
                if cur.Value == val </span><span class="cov8" title="1">{
                        return cur
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (d *DList) DelByVal(val string) <span class="cov8" title="1">{
        cur := d.findNode(val)
        if cur == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if cur.Prev != nil </span><span class="cov8" title="1">{
                cur.Prev.Next = cur.Next
        }</span> else<span class="cov8" title="1"> {
                d.Head = cur.Next
        }</span>
        <span class="cov8" title="1">if cur.Next != nil </span><span class="cov8" title="1">{
                cur.Next.Prev = cur.Prev
        }</span> else<span class="cov8" title="1"> {
                d.Tail = cur.Prev
        }</span>
}

func (d *DList) Contains(val string) bool <span class="cov8" title="1">{
        return d.findNode(val) != nil
}</span>

func (d *DList) ReadForward() <span class="cov8" title="1">{
        if d.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст")
                return
        }</span>
        <span class="cov0" title="0">fmt.Print("Список вперед: ")
        for cur := d.Head; cur != nil; cur = cur.Next </span><span class="cov0" title="0">{
                fmt.Printf(" %s ", cur.Value)
        }</span>
        <span class="cov0" title="0">fmt.Println()</span>
}

func (d *DList) ReadBackward() <span class="cov8" title="1">{
        if d.Tail == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст")
                return
        }</span>
        <span class="cov0" title="0">fmt.Print("Список назад: ")
        for cur := d.Tail; cur != nil; cur = cur.Prev </span><span class="cov0" title="0">{
                fmt.Printf("\"%s\" ", cur.Value)
        }</span>
        <span class="cov0" title="0">fmt.Println()</span>
}

func (d *DList) DelAfterValue(val string) <span class="cov8" title="1">{
        targetNode := d.findNode(val)
        if targetNode == nil || targetNode.Next == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">d.DelByVal(targetNode.Next.Value)</span>
}

func (d *DList) DelBeforeValue(val string) <span class="cov8" title="1">{
        targetNode := d.findNode(val)
        if targetNode == nil || targetNode.Prev == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">d.DelByVal(targetNode.Prev.Value)</span>
}

func (d *DList) SaveToFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        var count int32 = 0
        for cur := d.Head; cur != nil; cur = cur.Next </span><span class="cov8" title="1">{
                count++
        }</span>
        <span class="cov8" title="1">if err := binary.Write(file, binary.LittleEndian, count); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for cur := d.Head; cur != nil; cur = cur.Next </span><span class="cov8" title="1">{
                if err := WriteString(file, cur.Value); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (d *DList) LoadFromFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        d.Head, d.Tail = nil, nil
        var count int32
        if err := binary.Read(file, binary.LittleEndian, &amp;count); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">for i := int32(0); i &lt; count; i++ </span><span class="cov8" title="1">{
                val, err := ReadString(file)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">d.AddTail(val)</span>
        }
        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">package ds

import (
        "fmt"
        "os"
)

func hashStr(key string, mod int) int <span class="cov8" title="1">{
        hashVal := 0
        for _, ch := range key </span><span class="cov8" title="1">{
                val := int(ch)
                if val &lt; 0 </span><span class="cov0" title="0">{
                        val = -val
                }</span>
                <span class="cov8" title="1">hashVal = (hashVal*31 + val) % mod</span>
        }
        <span class="cov8" title="1">return hashVal</span>
}

// --- ChainHash (Метод цепочек) ---

type ChainNode struct {
        Key  string
        Val  string
        Next *ChainNode
}

type ChainHash struct {
        Table []*ChainNode
        Cap   int
}

func NewChainHash(buckCount int) *ChainHash <span class="cov8" title="1">{
        if buckCount &lt; 1 </span><span class="cov8" title="1">{
                buckCount = 1
        }</span>
        <span class="cov8" title="1">return &amp;ChainHash{
                Table: make([]*ChainNode, buckCount),
                Cap:   buckCount,
        }</span>
}

func (c *ChainHash) Insert(key, val string) <span class="cov8" title="1">{
        idx := hashStr(key, c.Cap)
        cur := c.Table[idx]
        for cur != nil </span><span class="cov8" title="1">{
                if cur.Key == key </span><span class="cov8" title="1">{
                        cur.Val = val // Обновляем значение
                        return
                }</span>
                <span class="cov8" title="1">cur = cur.Next</span>
        }
        // Вставка в начало списка
        <span class="cov8" title="1">nd := &amp;ChainNode{Key: key, Val: val, Next: c.Table[idx]}
        c.Table[idx] = nd</span>
}

func (c *ChainHash) Erase(key string) bool <span class="cov8" title="1">{
        idx := hashStr(key, c.Cap)
        cur := c.Table[idx]
        var prev *ChainNode

        for cur != nil </span><span class="cov8" title="1">{
                if cur.Key == key </span><span class="cov8" title="1">{
                        if prev != nil </span><span class="cov8" title="1">{
                                prev.Next = cur.Next
                        }</span> else<span class="cov8" title="1"> {
                                c.Table[idx] = cur.Next
                        }</span>
                        <span class="cov8" title="1">return true</span>
                }
                <span class="cov8" title="1">prev = cur
                cur = cur.Next</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (c *ChainHash) Find(key string) string <span class="cov8" title="1">{
        idx := hashStr(key, c.Cap)
        cur := c.Table[idx]
        for cur != nil </span><span class="cov8" title="1">{
                if cur.Key == key </span><span class="cov8" title="1">{
                        return cur.Val
                }</span>
                <span class="cov8" title="1">cur = cur.Next</span>
        }
        <span class="cov8" title="1">return ""</span>
}

func (c *ChainHash) Show() <span class="cov8" title="1">{
        fmt.Print("цепочки: ")
        any := false
        for i, cur := range c.Table </span><span class="cov8" title="1">{
                if cur != nil </span><span class="cov8" title="1">{
                        any = true
                        fmt.Printf("[%d]: ", i)
                        for cur != nil </span><span class="cov8" title="1">{
                                fmt.Printf("%s-&gt;%s", cur.Key, cur.Val)
                                if cur.Next != nil </span><span class="cov0" title="0">{
                                        fmt.Print(" -&gt; ")
                                }</span>
                                <span class="cov8" title="1">cur = cur.Next</span>
                        }
                        <span class="cov8" title="1">fmt.Print("  ")</span>
                }
        }
        <span class="cov8" title="1">if !any </span><span class="cov8" title="1">{
                fmt.Print("пусто")
        }</span>
        <span class="cov8" title="1">fmt.Println()</span>
}

func (c *ChainHash) SaveToFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        if err := WriteInt32(file, int32(c.Cap)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var count int32 = 0
        for _, node := range c.Table </span><span class="cov8" title="1">{
                cur := node
                for cur != nil </span><span class="cov8" title="1">{
                        count++
                        cur = cur.Next
                }</span>
        }
        <span class="cov8" title="1">if err := WriteInt32(file, count); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, node := range c.Table </span><span class="cov8" title="1">{
                cur := node
                for cur != nil </span><span class="cov8" title="1">{
                        if err := WriteString(file, cur.Key); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if err := WriteString(file, cur.Val); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">cur = cur.Next</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (c *ChainHash) LoadFromFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        c.Table = nil

        capVal, err := ReadInt32(file)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">c.Cap = int(capVal)
        c.Table = make([]*ChainNode, c.Cap)

        count, err := ReadInt32(file)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for i := int32(0); i &lt; count; i++ </span><span class="cov8" title="1">{
                key, err := ReadString(file)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">val, err := ReadString(file)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">c.Insert(key, val)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// --- OpenHash (Открытая адресация) ---

type OpenEntry struct {
        Key     string
        Val     string
        Used    bool
        Deleted bool
}

type OpenHash struct {
        Table []OpenEntry
        Cap   int
}

func NewOpenHash(size int) *OpenHash <span class="cov8" title="1">{
        if size &lt; 1 </span><span class="cov8" title="1">{
                size = 1
        }</span>
        <span class="cov8" title="1">return &amp;OpenHash{
                Table: make([]OpenEntry, size),
                Cap:   size,
        }</span>
}

func (o *OpenHash) Insert(key, val string) <span class="cov8" title="1">{
        idx := hashStr(key, o.Cap)
        start := idx

        for </span><span class="cov8" title="1">{
                entry := &amp;o.Table[idx]

                // Нашли свободное место или место после удаления
                if !entry.Used &amp;&amp; !entry.Deleted </span><span class="cov8" title="1">{
                        entry.Key = key
                        entry.Val = val
                        entry.Used = true
                        entry.Deleted = false
                        return
                }</span>
                // Ключ уже есть - обновляем
                <span class="cov8" title="1">if entry.Used &amp;&amp; entry.Key == key </span><span class="cov8" title="1">{
                        entry.Val = val
                        return
                }</span>
                // Можно перезаписать удаленный слот
                <span class="cov8" title="1">if entry.Deleted </span><span class="cov8" title="1">{
                        // ВАЖНО: Надо проверить, нет ли этого ключа дальше в цепочке пробинга!
                        // Но для упрощенной реализации (как в C++ примере) пишем сюда.
                        entry.Key = key
                        entry.Val = val
                        entry.Used = true
                        entry.Deleted = false
                        return
                }</span>

                <span class="cov8" title="1">idx = (idx + 1) % o.Cap
                if idx == start </span><span class="cov8" title="1">{
                        fmt.Println("Таблица переполнена")
                        return
                }</span>
        }
}

func (o *OpenHash) Erase(key string) bool <span class="cov8" title="1">{
        idx := hashStr(key, o.Cap)
        start := idx

        for </span><span class="cov8" title="1">{
                entry := &amp;o.Table[idx]

                if entry.Used &amp;&amp; entry.Key == key </span><span class="cov8" title="1">{
                        entry.Used = false
                        entry.Deleted = true
                        return true
                }</span>
                // Если встретили пустую ячейку (не deleted), значит ключа нет
                <span class="cov8" title="1">if !entry.Used &amp;&amp; !entry.Deleted </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">idx = (idx + 1) % o.Cap
                if idx == start </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
}

func (o *OpenHash) Find(key string) string <span class="cov8" title="1">{
        idx := hashStr(key, o.Cap)
        start := idx

        for </span><span class="cov8" title="1">{
                entry := &amp;o.Table[idx]

                if entry.Used &amp;&amp; entry.Key == key </span><span class="cov8" title="1">{
                        return entry.Val
                }</span>
                <span class="cov8" title="1">if !entry.Used &amp;&amp; !entry.Deleted </span><span class="cov8" title="1">{
                        return ""
                }</span>

                <span class="cov8" title="1">idx = (idx + 1) % o.Cap
                if idx == start </span><span class="cov8" title="1">{
                        return ""
                }</span>
        }
}

func (o *OpenHash) Show() <span class="cov8" title="1">{
        fmt.Print("ОТКР.АДР: ")
        any := false
        for i, entry := range o.Table </span><span class="cov8" title="1">{
                if entry.Used </span><span class="cov8" title="1">{
                        any = true
                        fmt.Printf("[%d]%s-&gt;%s  ", i, entry.Key, entry.Val)
                }</span> else<span class="cov8" title="1"> if entry.Deleted </span><span class="cov0" title="0">{
                        any = true
                        fmt.Printf("[%d](удалено)  ", i)
                }</span>
        }
        <span class="cov8" title="1">if !any </span><span class="cov8" title="1">{
                fmt.Print("пусто")
        }</span>
        <span class="cov8" title="1">fmt.Println()</span>
}

func (o *OpenHash) SaveToFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        if err := WriteInt32(file, int32(o.Cap)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var count int32 = 0
        for _, entry := range o.Table </span><span class="cov8" title="1">{
                if entry.Used </span><span class="cov8" title="1">{
                        count++
                }</span>
        }
        <span class="cov8" title="1">if err := WriteInt32(file, count); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, entry := range o.Table </span><span class="cov8" title="1">{
                if entry.Used </span><span class="cov8" title="1">{
                        if err := WriteString(file, entry.Key); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if err := WriteString(file, entry.Val); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (o *OpenHash) LoadFromFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        capVal, err := ReadInt32(file)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">o.Cap = int(capVal)
        o.Table = make([]OpenEntry, o.Cap)

        count, err := ReadInt32(file)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for i := int32(0); i &lt; count; i++ </span><span class="cov8" title="1">{
                key, err := ReadString(file)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">val, err := ReadString(file)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">o.Insert(key, val)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func HashMan() <span class="cov8" title="1">{
        fmt.Println("УПРАВЛЕНИЕ ХЕШ-ТАБЛИЦАМИ")
        htChain := NewChainHash(10)
        htOpen := NewOpenHash(10)

        for </span><span class="cov8" title="1">{
                fmt.Println("\nКоманды: INSERT ключ значение | DELETE ключ | SEARCH ключ | SHOW | BACK")
                fmt.Print("Введите команду: ")

                var cmd, arg1, rest string
                fmt.Scan(&amp;cmd)

                if cmd == "BACK" </span><span class="cov8" title="1">{
                        fmt.Println("Выход из меню")
                        break</span>
                }
                <span class="cov8" title="1">if cmd == "SHOW" </span><span class="cov8" title="1">{
                        fmt.Println()
                        htChain.Show()
                        fmt.Println()
                        htOpen.Show()
                        continue</span>
                }

                <span class="cov8" title="1">if cmd == "INSERT" || cmd == "DELETE" || cmd == "SEARCH" </span><span class="cov8" title="1">{
                        fmt.Scan(&amp;arg1)
                }</span>
                <span class="cov8" title="1">if cmd == "INSERT" </span><span class="cov8" title="1">{
                        fmt.Scan(&amp;rest)
                }</span>

                <span class="cov8" title="1">if cmd == "INSERT" </span><span class="cov8" title="1">{
                        fmt.Println()
                        htChain.Insert(arg1, rest)
                        fmt.Println()
                        htOpen.Insert(arg1, rest)
                }</span> else<span class="cov8" title="1"> if cmd == "DELETE" </span><span class="cov8" title="1">{
                        fmt.Println()
                        htChain.Erase(arg1)
                        fmt.Println()
                        htOpen.Erase(arg1)
                }</span> else<span class="cov8" title="1"> if cmd == "SEARCH" </span><span class="cov8" title="1">{
                        fmt.Println()
                        v1 := htChain.Find(arg1)
                        v2 := htOpen.Find(arg1)
                        if v1 == "" </span><span class="cov8" title="1">{
                                v1 = "Not found"
                        }</span>
                        <span class="cov8" title="1">if v2 == "" </span><span class="cov8" title="1">{
                                v2 = "Not found"
                        }</span>
                        <span class="cov8" title="1">fmt.Printf("Chain: %s\n", v1)
                        fmt.Printf("Open:  %s\n", v2)</span>
                } else<span class="cov8" title="1"> {
                        fmt.Println("Неизвестная команда")
                }</span>
        }
        <span class="cov8" title="1">fmt.Println("========================================")</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package ds

import (
        "encoding/binary"
        "fmt"
        "os"
)

type ListNode struct {
        Value string
        Next  *ListNode
}

type MyList struct {
        Head *ListNode
}

func NewMyList() *MyList <span class="cov8" title="1">{
        return &amp;MyList{}
}</span>

func (l *MyList) AddHead(val string) <span class="cov8" title="1">{
        l.Head = &amp;ListNode{Value: val, Next: l.Head}
}</span>

func (l *MyList) AddTail(val string) <span class="cov8" title="1">{
        newNode := &amp;ListNode{Value: val}
        if l.Head == nil </span><span class="cov8" title="1">{
                l.Head = newNode
                return
        }</span>
        <span class="cov8" title="1">cur := l.Head
        for cur.Next != nil </span><span class="cov8" title="1">{
                cur = cur.Next
        }</span>
        <span class="cov8" title="1">cur.Next = newNode</span>
}

func (l *MyList) AddBefore(target, val string) <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст!")
                return
        }</span>
        <span class="cov8" title="1">if l.Head.Value == target </span><span class="cov8" title="1">{
                l.AddHead(val)
                return
        }</span>
        <span class="cov8" title="1">cur := l.Head
        for cur.Next != nil &amp;&amp; cur.Next.Value != target </span><span class="cov8" title="1">{
                cur = cur.Next
        }</span>
        <span class="cov8" title="1">if cur.Next == nil </span><span class="cov8" title="1">{
                fmt.Println("Элемент не найден")
                return
        }</span>
        <span class="cov0" title="0">newNode := &amp;ListNode{Value: val, Next: cur.Next}
        cur.Next = newNode</span>
}

func (l *MyList) AddAfter(target, val string) <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст")
                return
        }</span>
        <span class="cov8" title="1">cur := l.Head
        for cur != nil &amp;&amp; cur.Value != target </span><span class="cov8" title="1">{
                cur = cur.Next
        }</span>
        <span class="cov8" title="1">if cur == nil </span><span class="cov8" title="1">{
                fmt.Println("Элемент не найден")
                return
        }</span>
        <span class="cov8" title="1">newNode := &amp;ListNode{Value: val, Next: cur.Next}
        cur.Next = newNode</span>
}

func (l *MyList) DelHead() <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">l.Head = l.Head.Next</span>
}

func (l *MyList) DelTail() <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст")
                return
        }</span>
        <span class="cov8" title="1">if l.Head.Next == nil </span><span class="cov8" title="1">{
                l.Head = nil
                return
        }</span>
        <span class="cov8" title="1">cur := l.Head
        for cur.Next.Next != nil </span><span class="cov0" title="0">{
                cur = cur.Next
        }</span>
        <span class="cov8" title="1">cur.Next = nil</span>
}

func (l *MyList) DelByValue(val string) <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov0" title="0">{
                fmt.Println("Список пуст.")
                return
        }</span>
        <span class="cov8" title="1">if l.Head.Value == val </span><span class="cov8" title="1">{
                l.DelHead()
                fmt.Printf("Элемент %s удален.\n", val)
                return
        }</span>
        <span class="cov8" title="1">cur := l.Head
        for cur.Next != nil &amp;&amp; cur.Next.Value != val </span><span class="cov8" title="1">{
                cur = cur.Next
        }</span>
        <span class="cov8" title="1">if cur.Next == nil </span><span class="cov8" title="1">{
                fmt.Printf("Элемент %s не найден.\n", val)
                return
        }</span>
        <span class="cov8" title="1">cur.Next = cur.Next.Next
        fmt.Printf("Элемент %s удален.\n", val)</span>
}

func (l *MyList) DelAfterValue(val string) <span class="cov8" title="1">{
        if l.Head == nil || l.Head.Next == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">cur := l.Head
        for cur != nil &amp;&amp; cur.Value != val </span><span class="cov8" title="1">{
                cur = cur.Next
        }</span>
        <span class="cov8" title="1">if cur == nil || cur.Next == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">cur.Next = cur.Next.Next</span>
}

func (l *MyList) DelBeforeValue(val string) <span class="cov8" title="1">{
        if l.Head == nil || l.Head.Next == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if l.Head.Next.Value == val </span><span class="cov8" title="1">{
                l.DelHead()
                return
        }</span>
        <span class="cov8" title="1">cur := l.Head
        for cur.Next != nil &amp;&amp; cur.Next.Next != nil &amp;&amp; cur.Next.Next.Value != val </span><span class="cov8" title="1">{
                cur = cur.Next
        }</span>
        <span class="cov8" title="1">if cur.Next == nil || cur.Next.Next == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">cur.Next = cur.Next.Next</span>
}

func (l *MyList) FindValue(val string) bool <span class="cov8" title="1">{
        cur := l.Head
        for cur != nil </span><span class="cov8" title="1">{
                if cur.Value == val </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">cur = cur.Next</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (l *MyList) ReadForward() <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст")
                return
        }</span>
        <span class="cov0" title="0">fmt.Print("Список вперёд: ")
        for cur := l.Head; cur != nil; cur = cur.Next </span><span class="cov0" title="0">{
                fmt.Printf("\"%s\" ", cur.Value)
        }</span>
        <span class="cov0" title="0">fmt.Println()</span>
}

func (l *MyList) printBackRec(node *ListNode) <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">l.printBackRec(node.Next)
        fmt.Printf("\"%s\" ", node.Value)</span>
}

func (l *MyList) ReadBack() <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст")
                return
        }</span>
        <span class="cov8" title="1">fmt.Print("Список (назад): ")
        l.printBackRec(l.Head)
        fmt.Println()</span>
}

func (l *MyList) SaveToFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        var count int32 = 0
        for cur := l.Head; cur != nil; cur = cur.Next </span><span class="cov8" title="1">{
                count++
        }</span>
        <span class="cov8" title="1">if err := binary.Write(file, binary.LittleEndian, count); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for cur := l.Head; cur != nil; cur = cur.Next </span><span class="cov8" title="1">{
                if err := WriteString(file, cur.Value); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (l *MyList) LoadFromFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        l.Head = nil
        var count int32
        if err := binary.Read(file, binary.LittleEndian, &amp;count); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">for i := int32(0); i &lt; count; i++ </span><span class="cov8" title="1">{
                val, err := ReadString(file)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">l.AddTail(val)</span>
        }
        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file5" style="display: none">package ds

import (
        "encoding/binary"
        "fmt"
        "os"
)

type QNode struct {
        Data string
        Next *QNode
}

type Queue struct {
        Front *QNode
        Rear  *QNode
}

func NewQueue() *Queue <span class="cov8" title="1">{
        return &amp;Queue{}
}</span>

func (q *Queue) IsEmpty() bool <span class="cov8" title="1">{
        return q.Front == nil
}</span>

func (q *Queue) Push(val string) <span class="cov8" title="1">{
        newNode := &amp;QNode{Data: val, Next: nil}
        if q.IsEmpty() </span><span class="cov8" title="1">{
                q.Front = newNode
                q.Rear = newNode
        }</span> else<span class="cov8" title="1"> {
                q.Rear.Next = newNode
                q.Rear = newNode
        }</span>
}

func (q *Queue) Pop() string <span class="cov8" title="1">{
        if q.IsEmpty() </span><span class="cov8" title="1">{
                return "[QUEUE_EMPTY]"
        }</span>
        <span class="cov8" title="1">val := q.Front.Data
        q.Front = q.Front.Next
        if q.Front == nil </span><span class="cov8" title="1">{
                q.Rear = nil
        }</span>
        <span class="cov8" title="1">return val</span>
}

func (q *Queue) Peek() string <span class="cov8" title="1">{
        if q.IsEmpty() </span><span class="cov8" title="1">{
                return "[QUEUE_EMPTY]"
        }</span>
        <span class="cov8" title="1">return q.Front.Data</span>
}

func (q *Queue) Print() <span class="cov8" title="1">{
        if q.IsEmpty() </span><span class="cov8" title="1">{
                fmt.Println("Очередь пуста.")
                return
        }</span>
        <span class="cov0" title="0">fmt.Print("Очередь (начало -&gt; конец): ")
        for cur := q.Front; cur != nil; cur = cur.Next </span><span class="cov0" title="0">{
                fmt.Printf("\"%s\" ", cur.Data)
        }</span>
        <span class="cov0" title="0">fmt.Println()</span>
}

func (q *Queue) SaveToFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        var count int32 = 0
        for cur := q.Front; cur != nil; cur = cur.Next </span><span class="cov8" title="1">{
                count++
        }</span>
        <span class="cov8" title="1">if err := binary.Write(file, binary.LittleEndian, count); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for cur := q.Front; cur != nil; cur = cur.Next </span><span class="cov8" title="1">{
                if err := WriteString(file, cur.Data); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (q *Queue) LoadFromFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        q.Front, q.Rear = nil, nil
        var count int32
        if err := binary.Read(file, binary.LittleEndian, &amp;count); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">for i := int32(0); i &lt; count; i++ </span><span class="cov8" title="1">{
                val, err := ReadString(file)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">q.Push(val)</span>
        }
        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file6" style="display: none">package ds

import (
        "encoding/binary"
        "io"
)

// WriteString записывает строку в бинарном формате (длина int32 + байты)
func WriteString(w io.Writer, s string) error <span class="cov8" title="1">{
        length := int32(len(s))
        if err := WriteInt32(w, length); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if length &gt; 0 </span><span class="cov8" title="1">{
                if _, err := w.Write([]byte(s)); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// ReadString читает строку из бинарного формата
func ReadString(r io.Reader) (string, error) <span class="cov8" title="1">{
        length, err := ReadInt32(r)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">if length == 0 </span><span class="cov8" title="1">{
                return "", nil
        }</span>
        <span class="cov8" title="1">buf := make([]byte, length)
        if _, err := io.ReadFull(r, buf); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(buf), nil</span>
}

// WriteInt32 - вспомогательная функция для записи int32
// Если этой функции нет, cbt.go и hash.go будут падать с ошибкой undefined
func WriteInt32(w io.Writer, val int32) error <span class="cov8" title="1">{
        return binary.Write(w, binary.LittleEndian, val)
}</span>

// ReadInt32 - вспомогательная функция для чтения int32
// Если этой функции нет, cbt.go и hash.go будут падать с ошибкой undefined
func ReadInt32(r io.Reader) (int32, error) <span class="cov8" title="1">{
        var val int32
        err := binary.Read(r, binary.LittleEndian, &amp;val)
        return val, err
}</pre>
		
		<pre class="file" id="file7" style="display: none">package ds

import (
        "encoding/binary"
        "fmt"
        "os"
)

type SNode struct {
        Value string
        Next  *SNode
}

type Stack struct {
        Top *SNode
}

func NewStack() *Stack <span class="cov8" title="1">{
        return &amp;Stack{}
}</span>

func (s *Stack) Push(val string) <span class="cov8" title="1">{
        s.Top = &amp;SNode{Value: val, Next: s.Top}
}</span>

func (s *Stack) Pop() string <span class="cov8" title="1">{
        if s.Top == nil </span><span class="cov8" title="1">{
                return "[STACK_EMPTY]"
        }</span>
        <span class="cov8" title="1">val := s.Top.Value
        s.Top = s.Top.Next
        return val</span>
}

func (s *Stack) Peek() string <span class="cov8" title="1">{
        if s.Top == nil </span><span class="cov8" title="1">{
                return "[STACK_EMPTY]"
        }</span>
        <span class="cov8" title="1">return s.Top.Value</span>
}

func (s *Stack) IsEmpty() bool <span class="cov8" title="1">{
        return s.Top == nil
}</span>

func (s *Stack) ReadStack() <span class="cov8" title="1">{
        if s.Top == nil </span><span class="cov8" title="1">{
                fmt.Println("Стек пуст")
                return
        }</span>
        <span class="cov0" title="0">fmt.Println("Содержимое стека (сверху вниз): ")
        for cur := s.Top; cur != nil; cur = cur.Next </span><span class="cov0" title="0">{
                fmt.Printf("  %s\n", cur.Value)
        }</span>
}

func (s *Stack) SaveToFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Считаем кол-во и собираем во временный слайс для реверса
        var count int32 = 0
        var tempArr []string
        for cur := s.Top; cur != nil; cur = cur.Next </span><span class="cov8" title="1">{
                count++
                tempArr = append(tempArr, cur.Value)
        }</span>

        <span class="cov8" title="1">if err := binary.Write(file, binary.LittleEndian, count); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Пишем в обратном порядке (снизу вверх), чтобы при загрузке восстановить порядок
        <span class="cov8" title="1">for i := len(tempArr) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if err := WriteString(file, tempArr[i]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *Stack) LoadFromFile(filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        s.Top = nil
        var count int32
        if err := binary.Read(file, binary.LittleEndian, &amp;count); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">for i := int32(0); i &lt; count; i++ </span><span class="cov8" title="1">{
                val, err := ReadString(file)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">s.Push(val)</span>
        }
        <span class="cov8" title="1">return nil</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
