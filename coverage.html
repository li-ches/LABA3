
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>ds: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">datastructures/ds/arr.go (87.9%)</option>
				
				<option value="file1">datastructures/ds/arr_serialize.go (84.6%)</option>
				
				<option value="file2">datastructures/ds/cbt.go (100.0%)</option>
				
				<option value="file3">datastructures/ds/cbt_serialize.go (79.5%)</option>
				
				<option value="file4">datastructures/ds/dlist.go (89.9%)</option>
				
				<option value="file5">datastructures/ds/dlist_serialize.go (91.3%)</option>
				
				<option value="file6">datastructures/ds/hash.go (90.1%)</option>
				
				<option value="file7">datastructures/ds/hash_serialize.go (91.2%)</option>
				
				<option value="file8">datastructures/ds/list.go (94.3%)</option>
				
				<option value="file9">datastructures/ds/list_serialize.go (90.5%)</option>
				
				<option value="file10">datastructures/ds/queue.go (100.0%)</option>
				
				<option value="file11">datastructures/ds/queue_serialize.go (91.3%)</option>
				
				<option value="file12">datastructures/ds/serialize.go (82.4%)</option>
				
				<option value="file13">datastructures/ds/stack.go (100.0%)</option>
				
				<option value="file14">datastructures/ds/stack_serialize.go (84.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package ds

import "fmt"

type MyArr struct {
        data []string
}

func NewMyArr() *MyArr <span class="cov8" title="1">{
        return &amp;MyArr{
                data: make([]string, 0),
        }
}</span>

func (a *MyArr) AddEnd(val string) <span class="cov8" title="1">{
        a.data = append(a.data, val)
}</span>

func (a *MyArr) AddHead(val string) <span class="cov8" title="1">{
        a.data = append([]string{val}, a.data...)
}</span>

func (a *MyArr) AddAt(idx int, val string) <span class="cov8" title="1">{
        if idx &lt; 0 || idx &gt; len(a.data) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if idx == len(a.data) </span><span class="cov8" title="1">{
                a.AddEnd(val)
                return
        }</span>
        <span class="cov8" title="1">a.data = append(a.data[:idx+1], a.data[idx:]...)
        a.data[idx] = val</span>
}

func (a *MyArr) DelHead() <span class="cov8" title="1">{
        if len(a.data) == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">a.data = a.data[1:]</span>
}

func (a *MyArr) DelEnd() <span class="cov8" title="1">{
        if len(a.data) == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">a.data = a.data[:len(a.data)-1]</span>
}

func (a *MyArr) DelAt(idx int) <span class="cov8" title="1">{
        if idx &lt; 0 || idx &gt;= len(a.data) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">a.data = append(a.data[:idx], a.data[idx+1:]...)</span>
}

func (a *MyArr) RepArr(idx int, val string) <span class="cov8" title="1">{
        if idx &lt; 0 || idx &gt;= len(a.data) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">a.data[idx] = val</span>
}

func (a *MyArr) GetAt(idx int) string <span class="cov8" title="1">{
        if idx &gt;= 0 &amp;&amp; idx &lt; len(a.data) </span><span class="cov8" title="1">{
                return a.data[idx]
        }</span>
        <span class="cov8" title="1">return "[INVALID_INDEX]"</span>
}

func (a *MyArr) LenArr() int <span class="cov8" title="1">{
        return len(a.data)
}</span>

func (a *MyArr) ReadArray() <span class="cov8" title="1">{
        if len(a.data) == 0 </span><span class="cov8" title="1">{
                fmt.Println("Массив пуст.")
                return
        }</span>
        <span class="cov0" title="0">fmt.Printf("Содержимое массива (%d/%d): ", len(a.data), cap(a.data))
        for _, val := range a.data </span><span class="cov0" title="0">{
                fmt.Printf("\"%s\" ", val)
        }</span>
        <span class="cov0" title="0">fmt.Println()</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package ds

type ArrSerializer struct{}

func NewArrSerializer() *ArrSerializer <span class="cov8" title="1">{
        return &amp;ArrSerializer{}
}</span>

func (s *ArrSerializer) SaveToFile(arr *MyArr, filename string) error <span class="cov8" title="1">{
        return SaveStringsText(filename, arr.data)
}</span>

func (s *ArrSerializer) LoadFromFile(arr *MyArr, filename string) error <span class="cov8" title="1">{
        vals, err := LoadStringsText(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">arr.data = vals
        return nil</span>
}

func (s *ArrSerializer) SaveToBinaryFile(arr *MyArr, filename string) error <span class="cov8" title="1">{
        return SaveStringsBinary(filename, arr.data)
}</span>

func (s *ArrSerializer) LoadFromBinaryFile(arr *MyArr, filename string) error <span class="cov8" title="1">{
        vals, err := LoadStringsBinary(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">arr.data = vals
        return nil</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package ds

import "fmt"

type CBTNode struct {
        Data  int32
        Left  *CBTNode
        Right *CBTNode
}

type CompleteBinaryTree struct {
        Root *CBTNode
        Size int
}

func NewCBT() *CompleteBinaryTree <span class="cov8" title="1">{
        return &amp;CompleteBinaryTree{Root: nil, Size: 0}
}</span>

func (t *CompleteBinaryTree) insertRec(node *CBTNode, value int32) *CBTNode <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                t.Size++
                return &amp;CBTNode{Data: value}
        }</span>
        <span class="cov8" title="1">if value &lt; node.Data </span><span class="cov8" title="1">{
                node.Left = t.insertRec(node.Left, value)
        }</span> else<span class="cov8" title="1"> if value &gt; node.Data </span><span class="cov8" title="1">{
                node.Right = t.insertRec(node.Right, value)
        }</span>
        <span class="cov8" title="1">return node</span>
}

func (t *CompleteBinaryTree) Insert(value int) <span class="cov8" title="1">{
        t.Root = t.insertRec(t.Root, int32(value))
}</span>

func (t *CompleteBinaryTree) findMin(node *CBTNode) *CBTNode <span class="cov8" title="1">{
        for node != nil &amp;&amp; node.Left != nil </span><span class="cov8" title="1">{
                node = node.Left
        }</span>
        <span class="cov8" title="1">return node</span>
}

func (t *CompleteBinaryTree) deleteNodeRec(node *CBTNode, value int32) *CBTNode <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if value &lt; node.Data </span><span class="cov8" title="1">{
                node.Left = t.deleteNodeRec(node.Left, value)
        }</span> else<span class="cov8" title="1"> if value &gt; node.Data </span><span class="cov8" title="1">{
                node.Right = t.deleteNodeRec(node.Right, value)
        }</span> else<span class="cov8" title="1"> {
                if node.Left == nil </span><span class="cov8" title="1">{
                        t.Size--
                        return node.Right
                }</span>
                <span class="cov8" title="1">if node.Right == nil </span><span class="cov8" title="1">{
                        t.Size--
                        return node.Left
                }</span>
                <span class="cov8" title="1">successor := t.findMin(node.Right)
                node.Data = successor.Data
                node.Right = t.deleteNodeRec(node.Right, successor.Data)</span>
        }
        <span class="cov8" title="1">return node</span>
}

func (t *CompleteBinaryTree) Remove(value int) <span class="cov8" title="1">{
        if t.Root == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.Root = t.deleteNodeRec(t.Root, int32(value))</span>
}

func (t *CompleteBinaryTree) Search(value int) bool <span class="cov8" title="1">{
        val := int32(value)
        cur := t.Root
        for cur != nil </span><span class="cov8" title="1">{
                if cur.Data == val </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">if val &lt; cur.Data </span><span class="cov8" title="1">{
                        cur = cur.Left
                }</span> else<span class="cov8" title="1"> {
                        cur = cur.Right
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (t *CompleteBinaryTree) Contains(value int) bool <span class="cov8" title="1">{
        return t.Search(value)
}</span>

func (t *CompleteBinaryTree) Print() <span class="cov8" title="1">{
        if t.Root == nil </span><span class="cov8" title="1">{
                fmt.Println("Дерево пусто")
                return
        }</span>
        <span class="cov8" title="1">t.inOrderRec(t.Root)
        fmt.Println()</span>
}

func (t *CompleteBinaryTree) InorderPrint() <span class="cov8" title="1">{
        t.Print()
}</span>

func (t *CompleteBinaryTree) inOrderRec(n *CBTNode) <span class="cov8" title="1">{
        if n == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">t.inOrderRec(n.Left)
        fmt.Printf("%d ", n.Data)
        t.inOrderRec(n.Right)</span>
}

func (t *CompleteBinaryTree) Clear() <span class="cov8" title="1">{
        t.Root = nil
        t.Size = 0
}</span>

func (t *CompleteBinaryTree) countNodes(n *CBTNode) int <span class="cov8" title="1">{
        if n == nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return 1 + t.countNodes(n.Left) + t.countNodes(n.Right)</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">package ds

import (
        "os"
)

type CbtSerializer struct{}

func NewCbtSerializer() *CbtSerializer <span class="cov8" title="1">{
        return &amp;CbtSerializer{}
}</span>

func (s *CbtSerializer) SaveToFile(tree *CompleteBinaryTree, filename string) error <span class="cov8" title="1">{
        return SaveCBTText(filename, tree.Root)
}</span>

func (s *CbtSerializer) LoadFromFile(tree *CompleteBinaryTree, filename string) error <span class="cov8" title="1">{
        root, err := LoadCBTText(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">tree.Root = root
        tree.Size = tree.countNodes(tree.Root)
        return nil</span>
}

func writeBinaryRec(n *CBTNode, f *os.File) error <span class="cov8" title="1">{
        if n == nil </span><span class="cov8" title="1">{
                return WriteInt32(f, -1)
        }</span>
        <span class="cov8" title="1">if err := WriteInt32(f, n.Data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := writeBinaryRec(n.Left, f); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return writeBinaryRec(n.Right, f)</span>
}

func (s *CbtSerializer) SaveToBinaryFile(tree *CompleteBinaryTree, filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        return writeBinaryRec(tree.Root, file)</span>
}

func readBinaryRec(f *os.File) (*CBTNode, error) <span class="cov8" title="1">{
        val, err := ReadInt32(f)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if val == -1 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">node := &amp;CBTNode{Data: val}
        node.Left, err = readBinaryRec(f)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">node.Right, err = readBinaryRec(f)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return node, nil</span>
}

func (s *CbtSerializer) LoadFromBinaryFile(tree *CompleteBinaryTree, filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        tree.Clear()
        root, err := readBinaryRec(file)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">tree.Root = root
        tree.Size = tree.countNodes(tree.Root)
        return nil</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package ds

import "fmt"

type DNode struct {
        Value string
        Next  *DNode
        Prev  *DNode
}

type DList struct {
        Head *DNode
        Tail *DNode
}

func NewDList() *DList <span class="cov8" title="1">{
        return &amp;DList{}
}</span>

func (d *DList) AddHead(val string) <span class="cov8" title="1">{
        node := &amp;DNode{Value: val, Next: d.Head, Prev: nil}
        if d.Head != nil </span><span class="cov8" title="1">{
                d.Head.Prev = node
        }</span> else<span class="cov8" title="1"> {
                d.Tail = node
        }</span>
        <span class="cov8" title="1">d.Head = node</span>
}

func (d *DList) AddTail(val string) <span class="cov8" title="1">{
        node := &amp;DNode{Value: val, Next: nil, Prev: d.Tail}
        if d.Tail != nil </span><span class="cov8" title="1">{
                d.Tail.Next = node
        }</span> else<span class="cov8" title="1"> {
                d.Head = node
        }</span>
        <span class="cov8" title="1">d.Tail = node</span>
}

func (d *DList) AddBefore(target, val string) <span class="cov8" title="1">{
        if d.Head == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">for cur := d.Head; cur != nil; cur = cur.Next </span><span class="cov8" title="1">{
                if cur.Value == target </span><span class="cov8" title="1">{
                        node := &amp;DNode{Value: val, Next: cur, Prev: cur.Prev}
                        if cur.Prev != nil </span><span class="cov8" title="1">{
                                cur.Prev.Next = node
                        }</span> else<span class="cov8" title="1"> {
                                d.Head = node
                        }</span>
                        <span class="cov8" title="1">cur.Prev = node
                        return</span>
                }
        }
}

func (d *DList) AddAfter(target, val string) <span class="cov8" title="1">{
        if d.Head == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">for cur := d.Head; cur != nil; cur = cur.Next </span><span class="cov8" title="1">{
                if cur.Value == target </span><span class="cov8" title="1">{
                        node := &amp;DNode{Value: val, Next: cur.Next, Prev: cur}
                        if cur.Next != nil </span><span class="cov8" title="1">{
                                cur.Next.Prev = node
                        }</span> else<span class="cov8" title="1"> {
                                d.Tail = node
                        }</span>
                        <span class="cov8" title="1">cur.Next = node
                        return</span>
                }
        }
}

func (d *DList) DelHead() <span class="cov8" title="1">{
        if d.Head == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">d.Head = d.Head.Next
        if d.Head != nil </span><span class="cov8" title="1">{
                d.Head.Prev = nil
        }</span> else<span class="cov8" title="1"> {
                d.Tail = nil
        }</span>
}

func (d *DList) DelTail() <span class="cov8" title="1">{
        if d.Tail == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">d.Tail = d.Tail.Prev
        if d.Tail != nil </span><span class="cov8" title="1">{
                d.Tail.Next = nil
        }</span> else<span class="cov8" title="1"> {
                d.Head = nil
        }</span>
}

func (d *DList) findNode(val string) *DNode <span class="cov8" title="1">{
        for cur := d.Head; cur != nil; cur = cur.Next </span><span class="cov8" title="1">{
                if cur.Value == val </span><span class="cov8" title="1">{
                        return cur
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (d *DList) DelByVal(val string) <span class="cov8" title="1">{
        cur := d.findNode(val)
        if cur == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if cur.Prev != nil </span><span class="cov8" title="1">{
                cur.Prev.Next = cur.Next
        }</span> else<span class="cov8" title="1"> {
                d.Head = cur.Next
        }</span>
        <span class="cov8" title="1">if cur.Next != nil </span><span class="cov8" title="1">{
                cur.Next.Prev = cur.Prev
        }</span> else<span class="cov8" title="1"> {
                d.Tail = cur.Prev
        }</span>
}

func (d *DList) Contains(val string) bool <span class="cov8" title="1">{
        return d.findNode(val) != nil
}</span>

func (d *DList) ReadForward() <span class="cov8" title="1">{
        if d.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст")
                return
        }</span>
        <span class="cov0" title="0">fmt.Print("Список вперед: ")
        for cur := d.Head; cur != nil; cur = cur.Next </span><span class="cov0" title="0">{
                fmt.Printf(" %s ", cur.Value)
        }</span>
        <span class="cov0" title="0">fmt.Println()</span>
}

func (d *DList) ReadBackward() <span class="cov8" title="1">{
        if d.Tail == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст")
                return
        }</span>
        <span class="cov0" title="0">fmt.Print("Список назад: ")
        for cur := d.Tail; cur != nil; cur = cur.Prev </span><span class="cov0" title="0">{
                fmt.Printf("\"%s\" ", cur.Value)
        }</span>
        <span class="cov0" title="0">fmt.Println()</span>
}

func (d *DList) DelAfterValue(val string) <span class="cov8" title="1">{
        targetNode := d.findNode(val)
        if targetNode == nil || targetNode.Next == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">d.DelByVal(targetNode.Next.Value)</span>
}

func (d *DList) DelBeforeValue(val string) <span class="cov8" title="1">{
        targetNode := d.findNode(val)
        if targetNode == nil || targetNode.Prev == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">d.DelByVal(targetNode.Prev.Value)</span>
}</pre>
		
		<pre class="file" id="file5" style="display: none">package ds

type DListSerializer struct{}

func NewDListSerializer() *DListSerializer <span class="cov8" title="1">{
        return &amp;DListSerializer{}
}</span>

func (d *DList) toSlice() []string <span class="cov8" title="1">{
        out := []string{}
        for cur := d.Head; cur != nil; cur = cur.Next </span><span class="cov8" title="1">{
                out = append(out, cur.Value)
        }</span>
        <span class="cov8" title="1">return out</span>
}

func (s *DListSerializer) SaveToFile(dlist *DList, filename string) error <span class="cov8" title="1">{
        return SaveStringsText(filename, dlist.toSlice())
}</span>

func (s *DListSerializer) LoadFromFile(dlist *DList, filename string) error <span class="cov8" title="1">{
        vals, err := LoadStringsText(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">dlist.Head = nil
        dlist.Tail = nil
        for _, v := range vals </span><span class="cov8" title="1">{
                dlist.AddTail(v)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *DListSerializer) SaveToBinaryFile(dlist *DList, filename string) error <span class="cov8" title="1">{
        return SaveStringsBinary(filename, dlist.toSlice())
}</span>

func (s *DListSerializer) LoadFromBinaryFile(dlist *DList, filename string) error <span class="cov8" title="1">{
        vals, err := LoadStringsBinary(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">dlist.Head = nil
        dlist.Tail = nil
        for _, v := range vals </span><span class="cov8" title="1">{
                dlist.AddTail(v)
        }</span>
        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file6" style="display: none">package ds

import (
        "bufio"
        "fmt"
        "os"
        "strings"
)

func hashStr(key string, mod int) int <span class="cov8" title="1">{
        h := 0
        for _, ch := range key </span><span class="cov8" title="1">{
                v := int(ch)
                if v &lt; 0 </span><span class="cov0" title="0">{
                        v = -v
                }</span>
                <span class="cov8" title="1">h = (h*31 + v) % mod</span>
        }
        <span class="cov8" title="1">return h</span>
}

type ChainNode struct {
        Key  string
        Val  string
        Next *ChainNode
}

type ChainHash struct {
        Table []*ChainNode
        Cap   int
}

func NewChainHash(buckets int) *ChainHash <span class="cov8" title="1">{
        if buckets &lt; 1 </span><span class="cov0" title="0">{
                buckets = 1
        }</span>
        <span class="cov8" title="1">return &amp;ChainHash{
                Table: make([]*ChainNode, buckets),
                Cap:   buckets,
        }</span>
}

func (c *ChainHash) Insert(k, v string) <span class="cov8" title="1">{
        idx := hashStr(k, c.Cap)
        cur := c.Table[idx]

        for cur != nil </span><span class="cov8" title="1">{
                if cur.Key == k </span><span class="cov8" title="1">{
                        cur.Val = v
                        return
                }</span>
                <span class="cov8" title="1">cur = cur.Next</span>
        }

        <span class="cov8" title="1">c.Table[idx] = &amp;ChainNode{
                Key:  k,
                Val:  v,
                Next: c.Table[idx],
        }</span>
}

func (c *ChainHash) Find(key string) string <span class="cov8" title="1">{
        idx := hashStr(key, c.Cap)
        cur := c.Table[idx]
        for cur != nil </span><span class="cov8" title="1">{
                if cur.Key == key </span><span class="cov8" title="1">{
                        return cur.Val
                }</span>
                <span class="cov8" title="1">cur = cur.Next</span>
        }
        <span class="cov8" title="1">return ""</span>
}

func (c *ChainHash) Erase(key string) bool <span class="cov8" title="1">{
        idx := hashStr(key, c.Cap)
        cur := c.Table[idx]
        var prev *ChainNode = nil

        for cur != nil </span><span class="cov8" title="1">{
                if cur.Key == key </span><span class="cov8" title="1">{
                        if prev == nil </span><span class="cov8" title="1">{
                                c.Table[idx] = cur.Next
                        }</span> else<span class="cov8" title="1"> {
                                prev.Next = cur.Next
                        }</span>
                        <span class="cov8" title="1">return true</span>
                }
                <span class="cov8" title="1">prev = cur
                cur = cur.Next</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (c *ChainHash) Show() <span class="cov8" title="1">{
        fmt.Println("--- ChainHash Content ---")
        for i, node := range c.Table </span><span class="cov8" title="1">{
                if node != nil </span><span class="cov8" title="1">{
                        fmt.Printf("[%d]: ", i)
                        for cur := node; cur != nil; cur = cur.Next </span><span class="cov8" title="1">{
                                fmt.Printf("(%s-&gt;%s) -&gt; ", cur.Key, cur.Val)
                        }</span>
                        <span class="cov8" title="1">fmt.Println("nil")</span>
                }
        }
}

type OpenEntry struct {
        Key     string
        Val     string
        Used    bool
        Deleted bool
}

type OpenHash struct {
        Table []OpenEntry
        Cap   int
}

func NewOpenHash(size int) *OpenHash <span class="cov8" title="1">{
        if size &lt; 1 </span><span class="cov8" title="1">{
                size = 1
        }</span>
        <span class="cov8" title="1">return &amp;OpenHash{
                Table: make([]OpenEntry, size),
                Cap:   size,
        }</span>
}

func (o *OpenHash) Insert(k, v string) <span class="cov8" title="1">{
        idx := hashStr(k, o.Cap)
        start := idx

        for </span><span class="cov8" title="1">{
                e := &amp;o.Table[idx]

                if !e.Used &amp;&amp; !e.Deleted </span><span class="cov8" title="1">{
                        e.Key = k
                        e.Val = v
                        e.Used = true
                        return
                }</span>
                <span class="cov8" title="1">if e.Used &amp;&amp; e.Key == k </span><span class="cov8" title="1">{
                        e.Val = v
                        return
                }</span>
                <span class="cov8" title="1">if e.Deleted </span><span class="cov8" title="1">{
                        e.Key = k
                        e.Val = v
                        e.Used = true
                        e.Deleted = false
                        return
                }</span>

                <span class="cov8" title="1">idx = (idx + 1) % o.Cap
                if idx == start </span><span class="cov8" title="1">{
                        fmt.Println("OpenHash full!")
                        return
                }</span>
        }
}

func (o *OpenHash) Find(k string) string <span class="cov8" title="1">{
        idx := hashStr(k, o.Cap)
        start := idx

        for </span><span class="cov8" title="1">{
                e := &amp;o.Table[idx]

                if e.Used &amp;&amp; e.Key == k </span><span class="cov8" title="1">{
                        return e.Val
                }</span>
                <span class="cov8" title="1">if !e.Used &amp;&amp; !e.Deleted </span><span class="cov8" title="1">{
                        return ""
                }</span>

                <span class="cov8" title="1">idx = (idx + 1) % o.Cap
                if idx == start </span><span class="cov8" title="1">{
                        return ""
                }</span>
        }
}

func (o *OpenHash) Erase(k string) bool <span class="cov8" title="1">{
        idx := hashStr(k, o.Cap)
        start := idx

        for </span><span class="cov8" title="1">{
                e := &amp;o.Table[idx]

                if e.Used &amp;&amp; e.Key == k </span><span class="cov8" title="1">{
                        e.Used = false
                        e.Deleted = true
                        return true
                }</span>

                <span class="cov8" title="1">if !e.Used &amp;&amp; !e.Deleted </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">idx = (idx + 1) % o.Cap
                if idx == start </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
}

func (o *OpenHash) Show() <span class="cov8" title="1">{
        fmt.Println("--- OpenHash Content ---")
        for i, e := range o.Table </span><span class="cov8" title="1">{
                status := "EMPTY"
                if e.Used </span><span class="cov0" title="0">{
                        status = fmt.Sprintf("%s-&gt;%s", e.Key, e.Val)
                }</span> else<span class="cov8" title="1"> if e.Deleted </span><span class="cov0" title="0">{
                        status = "DELETED"
                }</span>
                <span class="cov8" title="1">fmt.Printf("[%d]: %s\n", i, status)</span>
        }
}

func HashMan() <span class="cov8" title="1">{
        scanner := bufio.NewScanner(os.Stdin)
        ch := NewChainHash(10)
        oh := NewOpenHash(10)

        currentMode := "chain"

        fmt.Println("Хеш-менеджер. Команды: CHAIN, OPEN, INSERT k v, SEARCH k, DELETE k, SHOW, BACK")

        for </span><span class="cov8" title="1">{
                fmt.Printf("[%s] &gt;&gt; ", currentMode)
                if !scanner.Scan() </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">line := scanner.Text()
                parts := strings.Fields(line)
                if len(parts) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">cmd := parts[0]

                switch cmd </span>{
                case "BACK":<span class="cov8" title="1">
                        return</span>
                case "CHAIN":<span class="cov8" title="1">
                        currentMode = "chain"
                        fmt.Println("Переключено на ChainHash")</span>
                case "OPEN":<span class="cov8" title="1">
                        currentMode = "open"
                        fmt.Println("Переключено на OpenHash")</span>
                case "SHOW":<span class="cov8" title="1">
                        if currentMode == "chain" </span><span class="cov8" title="1">{
                                ch.Show()
                        }</span> else<span class="cov0" title="0"> {
                                oh.Show()
                        }</span>
                case "INSERT":<span class="cov8" title="1">
                        if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                                fmt.Println("Нужен ключ и значение")
                                continue</span>
                        }
                        <span class="cov8" title="1">if currentMode == "chain" </span><span class="cov8" title="1">{
                                ch.Insert(parts[1], parts[2])
                        }</span> else<span class="cov8" title="1"> {
                                oh.Insert(parts[1], parts[2])
                        }</span>
                case "SEARCH":<span class="cov8" title="1">
                        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                                fmt.Println("Нужен ключ")
                                continue</span>
                        }
                        <span class="cov8" title="1">res := ""
                        if currentMode == "chain" </span><span class="cov8" title="1">{
                                res = ch.Find(parts[1])
                        }</span> else<span class="cov8" title="1"> {
                                res = oh.Find(parts[1])
                        }</span>
                        <span class="cov8" title="1">if res == "" </span><span class="cov8" title="1">{
                                fmt.Println("Не найдено")
                        }</span> else<span class="cov8" title="1"> {
                                fmt.Println("Найдено:", res)
                        }</span>
                case "DELETE":<span class="cov8" title="1">
                        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                                fmt.Println("Нужен ключ")
                                continue</span>
                        }
                        <span class="cov8" title="1">ok := false
                        if currentMode == "chain" </span><span class="cov8" title="1">{
                                ok = ch.Erase(parts[1])
                        }</span> else<span class="cov8" title="1"> {
                                ok = oh.Erase(parts[1])
                        }</span>
                        <span class="cov8" title="1">if ok </span><span class="cov8" title="1">{
                                fmt.Println("Удалено")
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println("Не найдено для удаления")
                        }</span>
                default:<span class="cov8" title="1">
                        fmt.Println("Неизвестная команда")</span>
                }
        }
}</pre>
		
		<pre class="file" id="file7" style="display: none">package ds

import (
        "bufio"
        "fmt"
        "os"
)

type HashSerializer struct{}

func NewHashSerializer() *HashSerializer <span class="cov8" title="1">{
        return &amp;HashSerializer{}
}</span>

func (s *HashSerializer) SaveToFile(hash interface{}, filename string) error <span class="cov8" title="1">{
        switch h := hash.(type) </span>{
        case *ChainHash:<span class="cov8" title="1">
                return s.saveChainHash(h, filename)</span>
        case *OpenHash:<span class="cov8" title="1">
                return s.saveOpenHash(h, filename)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported hash type")</span>
        }
}

func (s *HashSerializer) LoadFromFile(hash interface{}, filename string) error <span class="cov8" title="1">{
        switch h := hash.(type) </span>{
        case *ChainHash:<span class="cov8" title="1">
                return s.loadChainHash(h, filename)</span>
        case *OpenHash:<span class="cov8" title="1">
                return s.loadOpenHash(h, filename)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported hash type")</span>
        }
}

func (s *HashSerializer) SaveToBinaryFile(hash interface{}, filename string) error <span class="cov8" title="1">{
        switch h := hash.(type) </span>{
        case *ChainHash:<span class="cov8" title="1">
                return s.saveChainHashBinary(h, filename)</span>
        case *OpenHash:<span class="cov8" title="1">
                return s.saveOpenHashBinary(h, filename)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported hash type")</span>
        }
}

func (s *HashSerializer) LoadFromBinaryFile(hash interface{}, filename string) error <span class="cov8" title="1">{
        switch h := hash.(type) </span>{
        case *ChainHash:<span class="cov8" title="1">
                return s.loadChainHashBinary(h, filename)</span>
        case *OpenHash:<span class="cov8" title="1">
                return s.loadOpenHashBinary(h, filename)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported hash type")</span>
        }
}

func (s *HashSerializer) saveChainHash(ch *ChainHash, filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        fmt.Fprintln(file, ch.Cap)
        count := 0
        for _, n := range ch.Table </span><span class="cov8" title="1">{
                for cur := n; cur != nil; cur = cur.Next </span><span class="cov8" title="1">{
                        count++
                }</span>
        }
        <span class="cov8" title="1">fmt.Fprintln(file, count)

        for _, n := range ch.Table </span><span class="cov8" title="1">{
                for cur := n; cur != nil; cur = cur.Next </span><span class="cov8" title="1">{
                        WriteStringText(file, cur.Key)
                        WriteStringText(file, cur.Val)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *HashSerializer) loadChainHash(ch *ChainHash, filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        sc := bufio.NewScanner(file)
        var capVal, count int
        if sc.Scan() </span><span class="cov8" title="1">{
                fmt.Sscanf(sc.Text(), "%d", &amp;capVal)
        }</span>

        <span class="cov8" title="1">ch.Cap = capVal
        ch.Table = make([]*ChainNode, ch.Cap)

        if sc.Scan() </span><span class="cov8" title="1">{
                fmt.Sscanf(sc.Text(), "%d", &amp;count)
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                k := ReadStringText(sc)
                v := ReadStringText(sc)
                ch.Insert(k, v)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *HashSerializer) saveChainHashBinary(ch *ChainHash, filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        WriteInt32(file, int32(ch.Cap))
        count := 0
        for _, n := range ch.Table </span><span class="cov8" title="1">{
                for cur := n; cur != nil; cur = cur.Next </span><span class="cov8" title="1">{
                        count++
                }</span>
        }
        <span class="cov8" title="1">WriteInt32(file, int32(count))

        for _, n := range ch.Table </span><span class="cov8" title="1">{
                for cur := n; cur != nil; cur = cur.Next </span><span class="cov8" title="1">{
                        WriteString(file, cur.Key)
                        WriteString(file, cur.Val)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *HashSerializer) loadChainHashBinary(ch *ChainHash, filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        capVal, _ := ReadInt32(file)
        ch.Cap = int(capVal)
        ch.Table = make([]*ChainNode, ch.Cap)

        count, _ := ReadInt32(file)
        for i := 0; i &lt; int(count); i++ </span><span class="cov8" title="1">{
                k, _ := ReadString(file)
                v, _ := ReadString(file)
                ch.Insert(k, v)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *HashSerializer) saveOpenHash(oh *OpenHash, filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        fmt.Fprintln(file, oh.Cap)
        count := 0
        for _, e := range oh.Table </span><span class="cov8" title="1">{
                if e.Used </span><span class="cov8" title="1">{
                        count++
                }</span>
        }
        <span class="cov8" title="1">fmt.Fprintln(file, count)

        for _, e := range oh.Table </span><span class="cov8" title="1">{
                if e.Used </span><span class="cov8" title="1">{
                        WriteStringText(file, e.Key)
                        WriteStringText(file, e.Val)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *HashSerializer) loadOpenHash(oh *OpenHash, filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        sc := bufio.NewScanner(file)
        var capVal, count int
        if sc.Scan() </span><span class="cov8" title="1">{
                fmt.Sscanf(sc.Text(), "%d", &amp;capVal)
        }</span>
        <span class="cov8" title="1">oh.Cap = capVal
        oh.Table = make([]OpenEntry, capVal)

        if sc.Scan() </span><span class="cov8" title="1">{
                fmt.Sscanf(sc.Text(), "%d", &amp;count)
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                k := ReadStringText(sc)
                v := ReadStringText(sc)
                oh.Insert(k, v)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *HashSerializer) saveOpenHashBinary(oh *OpenHash, filename string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        WriteInt32(file, int32(oh.Cap))
        count := 0
        for _, e := range oh.Table </span><span class="cov8" title="1">{
                if e.Used </span><span class="cov8" title="1">{
                        count++
                }</span>
        }
        <span class="cov8" title="1">WriteInt32(file, int32(count))

        for _, e := range oh.Table </span><span class="cov8" title="1">{
                if e.Used </span><span class="cov8" title="1">{
                        WriteString(file, e.Key)
                        WriteString(file, e.Val)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *HashSerializer) loadOpenHashBinary(oh *OpenHash, filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        capVal, _ := ReadInt32(file)
        oh.Cap = int(capVal)
        oh.Table = make([]OpenEntry, oh.Cap)

        count, _ := ReadInt32(file)
        for i := 0; i &lt; int(count); i++ </span><span class="cov8" title="1">{
                k, _ := ReadString(file)
                v, _ := ReadString(file)
                oh.Insert(k, v)
        }</span>
        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file8" style="display: none">package ds

import "fmt"

type ListNode struct {
        Value string
        Next  *ListNode
}

type MyList struct {
        Head *ListNode
}

func NewMyList() *MyList <span class="cov8" title="1">{
        return &amp;MyList{}
}</span>

func (l *MyList) AddHead(val string) <span class="cov8" title="1">{
        l.Head = &amp;ListNode{Value: val, Next: l.Head}
}</span>

func (l *MyList) AddTail(val string) <span class="cov8" title="1">{
        newNode := &amp;ListNode{Value: val}
        if l.Head == nil </span><span class="cov8" title="1">{
                l.Head = newNode
                return
        }</span>
        <span class="cov8" title="1">cur := l.Head
        for cur.Next != nil </span><span class="cov8" title="1">{
                cur = cur.Next
        }</span>
        <span class="cov8" title="1">cur.Next = newNode</span>
}

func (l *MyList) AddBefore(target, val string) <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст!")
                return
        }</span>
        <span class="cov8" title="1">if l.Head.Value == target </span><span class="cov8" title="1">{
                l.AddHead(val)
                return
        }</span>
        <span class="cov8" title="1">cur := l.Head
        for cur.Next != nil &amp;&amp; cur.Next.Value != target </span><span class="cov8" title="1">{
                cur = cur.Next
        }</span>
        <span class="cov8" title="1">if cur.Next == nil </span><span class="cov8" title="1">{
                fmt.Println("Элемент не найден")
                return
        }</span>
        <span class="cov8" title="1">newNode := &amp;ListNode{Value: val, Next: cur.Next}
        cur.Next = newNode</span>
}

func (l *MyList) AddAfter(target, val string) <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст")
                return
        }</span>
        <span class="cov8" title="1">cur := l.Head
        for cur != nil &amp;&amp; cur.Value != target </span><span class="cov8" title="1">{
                cur = cur.Next
        }</span>
        <span class="cov8" title="1">if cur == nil </span><span class="cov8" title="1">{
                fmt.Println("Элемент не найден")
                return
        }</span>
        <span class="cov8" title="1">newNode := &amp;ListNode{Value: val, Next: cur.Next}
        cur.Next = newNode</span>
}

func (l *MyList) DelHead() <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">l.Head = l.Head.Next</span>
}

func (l *MyList) DelTail() <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст")
                return
        }</span>
        <span class="cov8" title="1">if l.Head.Next == nil </span><span class="cov8" title="1">{
                l.Head = nil
                return
        }</span>
        <span class="cov8" title="1">cur := l.Head
        for cur.Next.Next != nil </span><span class="cov0" title="0">{
                cur = cur.Next
        }</span>
        <span class="cov8" title="1">cur.Next = nil</span>
}

func (l *MyList) DelByValue(val string) <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст.")
                return
        }</span>
        <span class="cov8" title="1">if l.Head.Value == val </span><span class="cov8" title="1">{
                l.DelHead()
                fmt.Printf("Элемент %s удален.\n", val)
                return
        }</span>
        <span class="cov8" title="1">cur := l.Head
        for cur.Next != nil &amp;&amp; cur.Next.Value != val </span><span class="cov8" title="1">{
                cur = cur.Next
        }</span>
        <span class="cov8" title="1">if cur.Next == nil </span><span class="cov8" title="1">{
                fmt.Printf("Элемент %s не найден.\n", val)
                return
        }</span>
        <span class="cov8" title="1">cur.Next = cur.Next.Next
        fmt.Printf("Элемент %s удален.\n", val)</span>
}

func (l *MyList) DelAfterValue(val string) <span class="cov8" title="1">{
        if l.Head == nil || l.Head.Next == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">cur := l.Head
        for cur != nil &amp;&amp; cur.Value != val </span><span class="cov8" title="1">{
                cur = cur.Next
        }</span>
        <span class="cov8" title="1">if cur == nil || cur.Next == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">cur.Next = cur.Next.Next</span>
}

func (l *MyList) DelBeforeValue(val string) <span class="cov8" title="1">{
        if l.Head == nil || l.Head.Next == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if l.Head.Next.Value == val </span><span class="cov8" title="1">{
                l.DelHead()
                return
        }</span>
        <span class="cov8" title="1">cur := l.Head
        for cur.Next != nil &amp;&amp; cur.Next.Next != nil &amp;&amp; cur.Next.Next.Value != val </span><span class="cov8" title="1">{
                cur = cur.Next
        }</span>
        <span class="cov8" title="1">if cur.Next == nil || cur.Next.Next == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">cur.Next = cur.Next.Next</span>
}

func (l *MyList) FindValue(val string) bool <span class="cov8" title="1">{
        cur := l.Head
        for cur != nil </span><span class="cov8" title="1">{
                if cur.Value == val </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">cur = cur.Next</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (l *MyList) ReadForward() <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст")
                return
        }</span>
        <span class="cov0" title="0">fmt.Print("Список вперёд: ")
        for cur := l.Head; cur != nil; cur = cur.Next </span><span class="cov0" title="0">{
                fmt.Printf("\"%s\" ", cur.Value)
        }</span>
        <span class="cov0" title="0">fmt.Println()</span>
}

func (l *MyList) printBackRec(node *ListNode) <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">l.printBackRec(node.Next)
        fmt.Printf("\"%s\" ", node.Value)</span>
}

func (l *MyList) ReadBack() <span class="cov8" title="1">{
        if l.Head == nil </span><span class="cov8" title="1">{
                fmt.Println("Список пуст")
                return
        }</span>
        <span class="cov8" title="1">fmt.Print("Список (назад): ")
        l.printBackRec(l.Head)
        fmt.Println()</span>
}</pre>
		
		<pre class="file" id="file9" style="display: none">package ds

type ListSerializer struct{}

func NewListSerializer() *ListSerializer <span class="cov8" title="1">{
        return &amp;ListSerializer{}
}</span>

func (l *MyList) toSlice() []string <span class="cov8" title="1">{
        out := []string{}
        for cur := l.Head; cur != nil; cur = cur.Next </span><span class="cov8" title="1">{
                out = append(out, cur.Value)
        }</span>
        <span class="cov8" title="1">return out</span>
}

func (s *ListSerializer) SaveToFile(list *MyList, filename string) error <span class="cov8" title="1">{
        return SaveStringsText(filename, list.toSlice())
}</span>

func (s *ListSerializer) LoadFromFile(list *MyList, filename string) error <span class="cov8" title="1">{
        vals, err := LoadStringsText(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">list.Head = nil
        for _, v := range vals </span><span class="cov8" title="1">{
                list.AddTail(v)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *ListSerializer) SaveToBinaryFile(list *MyList, filename string) error <span class="cov8" title="1">{
        return SaveStringsBinary(filename, list.toSlice())
}</span>

func (s *ListSerializer) LoadFromBinaryFile(list *MyList, filename string) error <span class="cov8" title="1">{
        vals, err := LoadStringsBinary(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">list.Head = nil
        for _, v := range vals </span><span class="cov8" title="1">{
                list.AddTail(v)
        }</span>
        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file10" style="display: none">package ds

import "fmt"

type QNode struct {
        Data string
        Next *QNode
}

type Queue struct {
        Front *QNode
        Rear  *QNode
}

func NewQueue() *Queue <span class="cov8" title="1">{
        return &amp;Queue{}
}</span>

func (q *Queue) IsEmpty() bool <span class="cov8" title="1">{
        return q.Front == nil
}</span>

func (q *Queue) Push(val string) <span class="cov8" title="1">{
        newNode := &amp;QNode{Data: val, Next: nil}
        if q.IsEmpty() </span><span class="cov8" title="1">{
                q.Front = newNode
                q.Rear = newNode
        }</span> else<span class="cov8" title="1"> {
                q.Rear.Next = newNode
                q.Rear = newNode
        }</span>
}

func (q *Queue) Pop() string <span class="cov8" title="1">{
        if q.IsEmpty() </span><span class="cov8" title="1">{
                return "[QUEUE_EMPTY]"
        }</span>
        <span class="cov8" title="1">val := q.Front.Data
        q.Front = q.Front.Next
        if q.Front == nil </span><span class="cov8" title="1">{
                q.Rear = nil
        }</span>
        <span class="cov8" title="1">return val</span>
}

func (q *Queue) Peek() string <span class="cov8" title="1">{
        if q.IsEmpty() </span><span class="cov8" title="1">{
                return "[QUEUE_EMPTY]"
        }</span>
        <span class="cov8" title="1">return q.Front.Data</span>
}

func (q *Queue) Print() <span class="cov8" title="1">{
        if q.IsEmpty() </span><span class="cov8" title="1">{
                fmt.Println("Очередь пуста.")
                return
        }</span>
        <span class="cov8" title="1">fmt.Print("Очередь (начало -&gt; конец): ")
        for cur := q.Front; cur != nil; cur = cur.Next </span><span class="cov8" title="1">{
                fmt.Printf("\"%s\" ", cur.Data)
        }</span>
        <span class="cov8" title="1">fmt.Println()</span>
}</pre>
		
		<pre class="file" id="file11" style="display: none">package ds

type QueueSerializer struct{}

func NewQueueSerializer() *QueueSerializer <span class="cov8" title="1">{
        return &amp;QueueSerializer{}
}</span>

func (q *Queue) toSlice() []string <span class="cov8" title="1">{
        out := []string{}
        for cur := q.Front; cur != nil; cur = cur.Next </span><span class="cov8" title="1">{
                out = append(out, cur.Data)
        }</span>
        <span class="cov8" title="1">return out</span>
}

func (s *QueueSerializer) SaveToFile(queue *Queue, filename string) error <span class="cov8" title="1">{
        return SaveStringsText(filename, queue.toSlice())
}</span>

func (s *QueueSerializer) LoadFromFile(queue *Queue, filename string) error <span class="cov8" title="1">{
        vals, err := LoadStringsText(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">queue.Front = nil
        queue.Rear = nil
        for _, v := range vals </span><span class="cov8" title="1">{
                queue.Push(v)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *QueueSerializer) SaveToBinaryFile(queue *Queue, filename string) error <span class="cov8" title="1">{
        return SaveStringsBinary(filename, queue.toSlice())
}</span>

func (s *QueueSerializer) LoadFromBinaryFile(queue *Queue, filename string) error <span class="cov8" title="1">{
        vals, err := LoadStringsBinary(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">queue.Front = nil
        queue.Rear = nil
        for _, v := range vals </span><span class="cov8" title="1">{
                queue.Push(v)
        }</span>
        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file12" style="display: none">package ds

import (
        "bufio"
        "encoding/binary"
        "fmt"
        "io"
        "os"
        "strings"
)

func SaveStringsText(filename string, data []string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        fmt.Fprintln(file, len(data))
        for _, v := range data </span><span class="cov8" title="1">{
                fmt.Fprintln(file, v)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func LoadStringsText(filename string) ([]string, error) <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        sc := bufio.NewScanner(file)
        if !sc.Scan() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("empty file")
        }</span>

        <span class="cov8" title="1">var count int
        if _, err := fmt.Sscanf(sc.Text(), "%d", &amp;count); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := make([]string, 0, count)
        for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                if !sc.Scan() </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected EOF")
                }</span>
                <span class="cov8" title="1">result = append(result, strings.TrimSpace(sc.Text()))</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

func WriteStringText(f io.Writer, s string) <span class="cov8" title="1">{
        fmt.Fprintln(f, s)
}</span>

func ReadStringText(scanner *bufio.Scanner) string <span class="cov8" title="1">{
        if scanner.Scan() </span><span class="cov8" title="1">{
                return scanner.Text()
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func SaveStringsBinary(filename string, data []string) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        if err := binary.Write(file, binary.LittleEndian, int32(len(data))); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, v := range data </span><span class="cov8" title="1">{
                if err := WriteString(file, v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func LoadStringsBinary(filename string) ([]string, error) <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        var count int32
        if err := binary.Read(file, binary.LittleEndian, &amp;count); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := make([]string, 0, count)
        for i := int32(0); i &lt; count; i++ </span><span class="cov8" title="1">{
                v, err := ReadString(file)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">result = append(result, v)</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

func WriteInt32(w io.Writer, v int32) error <span class="cov8" title="1">{
        return binary.Write(w, binary.LittleEndian, v)
}</span>

func ReadInt32(r io.Reader) (int32, error) <span class="cov8" title="1">{
        var v int32
        err := binary.Read(r, binary.LittleEndian, &amp;v)
        return v, err
}</span>

func WriteString(w io.Writer, s string) error <span class="cov8" title="1">{
        if err := WriteInt32(w, int32(len(s))); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">_, err := w.Write([]byte(s))
        return err</span>
}

func ReadString(r io.Reader) (string, error) <span class="cov8" title="1">{
        ln, err := ReadInt32(r)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">buf := make([]byte, ln)
        n, err := io.ReadFull(r, buf)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">if int32(n) != ln </span><span class="cov0" title="0">{
                return "", fmt.Errorf("unexpected EOF")
        }</span>
        <span class="cov8" title="1">return string(buf), nil</span>
}

func SaveCBTText(filename string, root *CBTNode) error <span class="cov8" title="1">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        var dfs func(n *CBTNode)
        dfs = func(n *CBTNode) </span><span class="cov8" title="1">{
                if n == nil </span><span class="cov8" title="1">{
                        fmt.Fprintln(file, "#")
                        return
                }</span>
                <span class="cov8" title="1">fmt.Fprintln(file, n.Data)
                dfs(n.Left)
                dfs(n.Right)</span>
        }
        <span class="cov8" title="1">dfs(root)
        return nil</span>
}

func LoadCBTText(filename string) (*CBTNode, error) <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        sc := bufio.NewScanner(file)
        tokens := []string{}
        for sc.Scan() </span><span class="cov8" title="1">{
                tokens = append(tokens, strings.TrimSpace(sc.Text()))
        }</span>

        <span class="cov8" title="1">pos := 0
        var dfs func() *CBTNode
        dfs = func() *CBTNode </span><span class="cov8" title="1">{
                if pos &gt;= len(tokens) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">t := tokens[pos]
                pos++
                if t == "#" </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">var val int32
                fmt.Sscanf(t, "%d", &amp;val)
                n := &amp;CBTNode{Data: val}
                n.Left = dfs()
                n.Right = dfs()
                return n</span>
        }
        <span class="cov8" title="1">return dfs(), nil</span>
}</pre>
		
		<pre class="file" id="file13" style="display: none">package ds

import "fmt"

type SNode struct {
        Value string
        Next  *SNode
}

type Stack struct {
        Top *SNode
}

func NewStack() *Stack <span class="cov8" title="1">{
        return &amp;Stack{}
}</span>

func (s *Stack) Push(val string) <span class="cov8" title="1">{
        s.Top = &amp;SNode{Value: val, Next: s.Top}
}</span>

func (s *Stack) Pop() string <span class="cov8" title="1">{
        if s.Top == nil </span><span class="cov8" title="1">{
                return "[STACK_EMPTY]"
        }</span>
        <span class="cov8" title="1">val := s.Top.Value
        s.Top = s.Top.Next
        return val</span>
}

func (s *Stack) Peek() string <span class="cov8" title="1">{
        if s.Top == nil </span><span class="cov8" title="1">{
                return "[STACK_EMPTY]"
        }</span>
        <span class="cov8" title="1">return s.Top.Value</span>
}

func (s *Stack) IsEmpty() bool <span class="cov8" title="1">{
        return s.Top == nil
}</span>

func (s *Stack) ReadStack() <span class="cov8" title="1">{
        if s.Top == nil </span><span class="cov8" title="1">{
                fmt.Println("Стек пуст")
                return
        }</span>
        <span class="cov8" title="1">fmt.Println("Содержимое стека (сверху вниз): ")
        for cur := s.Top; cur != nil; cur = cur.Next </span><span class="cov8" title="1">{
                fmt.Printf("  %s\n", cur.Value)
        }</span>
}</pre>
		
		<pre class="file" id="file14" style="display: none">package ds

import (
        "bufio"
        "fmt"
        "os"
)

type StackSerializer struct{}

func NewStackSerializer() *StackSerializer <span class="cov8" title="1">{
        return &amp;StackSerializer{}
}</span>

func (s *Stack) toSlice() []string <span class="cov8" title="1">{
        out := []string{}
        for cur := s.Top; cur != nil; cur = cur.Next </span><span class="cov8" title="1">{
                out = append(out, cur.Value)
        }</span>
        <span class="cov8" title="1">return out</span>
}

func (s *StackSerializer) SaveToFile(stack *Stack, filename string) error <span class="cov8" title="1">{
        arr := stack.toSlice()
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        fmt.Fprintln(file, len(arr))
        for i := len(arr) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                WriteStringText(file, arr[i])
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *StackSerializer) LoadFromFile(stack *Stack, filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        stack.Top = nil
        scanner := bufio.NewScanner(file)

        var count int
        if scanner.Scan() </span><span class="cov8" title="1">{
                fmt.Sscanf(scanner.Text(), "%d", &amp;count)
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                val := ReadStringText(scanner)
                stack.Push(val)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *StackSerializer) SaveToBinaryFile(stack *Stack, filename string) error <span class="cov8" title="1">{
        arr := stack.toSlice()
        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        if err := WriteInt32(file, int32(len(arr))); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for i := len(arr) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if err := WriteString(file, arr[i]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *StackSerializer) LoadFromBinaryFile(stack *Stack, filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        stack.Top = nil

        count, err := ReadInt32(file)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; int(count); i++ </span><span class="cov8" title="1">{
                val, err := ReadString(file)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">stack.Push(val)</span>
        }
        <span class="cov8" title="1">return nil</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
